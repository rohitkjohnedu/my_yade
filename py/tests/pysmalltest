#!/bin/bash
# autopkgtest check for minieigen
# (C) 2015 Anton Gladky <gladk@debian.org>
# (C) 2019 Janek Kozicki

set -e

LIBTOTEST=${1}
DEC_DIGITS=${2}

WORKDIR=$(mktemp -d)
trap "rm -rf $WORKDIR" 0 INT QUIT ABRT PIPE TERM
cp ${LIBTOTEST}.so ${WORKDIR}
cd ${WORKDIR}

cat <<EOF > pysmalltest.py
import unittest, math, sys, mpmath
import ${LIBTOTEST} as mne

class SimpleTests(unittest.TestCase):
	def setUp(self):
		mpmath.mp.dps=${DEC_DIGITS}+1
		# tolerance = 1.001×10⁻ᵈ⁺¹, where ᵈ==${DEC_DIGITS}
		# so basically we store one more decimal digit, and expect one less decimal digit. That amounts to ignoring one (actually two) least significant digits.
		self.tolerance=(mpmath.mpf(10)**(-${DEC_DIGITS}+1))*mpmath.mpf("1.001")
	def checkRelativeError(self,a,b):
		self.assertLessEqual(abs( (mpmath.mpf(a)-mpmath.mpf(b))/mpmath.mpf(b) ),self.tolerance)
	def testSimple(self):
		zz=mpmath.acos(0)
		print(zz.__repr__())
		print("zz:",hex(id(zz)))
		print("mpmath:",hex(id(mpmath)))
		a=mne.Var()
		a.val=zz
		self.assertEqual(mpmath.mp.dps , ${DEC_DIGITS}+1 )
		print("---- a.val=",a.val.__repr__())
		print("---- zz   =",zz   .__repr__())
		print("---- DPS  =",mpmath.mp.dps)
		print("---- abs  =",abs(mpmath.mpf(a.val-zz)))
		print("---- 10** =",self.tolerance)
		#self.assertAlmostEqual(a.val,zz)
		self.checkRelativeError(a.val,zz)

if __name__ == '__main__':
		unittest.main(testRunner=unittest.TextTestRunner(stream=sys.stdout, verbosity=2))
EOF

function handle_error() {
	ls -la
	gdb --batch -ex "bt full" `which python3` ./core
	exit 1
}

echo 'Test Python3'
ulimit -c unlimited
python3 pysmalltest.py || handle_error
echo "Python3 run: OK"

cd
rm -rf ${WORKDIR}

